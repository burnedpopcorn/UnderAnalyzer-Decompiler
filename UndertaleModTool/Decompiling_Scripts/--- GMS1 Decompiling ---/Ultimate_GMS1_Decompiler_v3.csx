/*
    Ultimate_GMS1_Decompiler_v3.csx
        Improved by burnedpopcorn180

            Original Script by cubeww
            Fixed Version by CST1229

    This Script is Compatible with Both My UnderAnalyzer Decompiler
    and Bleeding Edge UTMT 0.8.3.0+

    Ultimate_GMS1_Decompiler_v3 Changes:
        - Added support for Options and Icon Extraction
        - Added support for Automatically Importing Datafiles
        - Cleaned Up all UI code
        - Fixed Shader Trimming

    Ultimate_GMS1_Decompiler_v2 Changes:
        - Rewrote UI to look better and use Dark Mode
        - Script now decompiles all asset types asynchronously
        - Cleaned up previous code
		
    Ultimate_GMS1_Decompiler Changes:
        - UI has been added, with the ability to select specific resource types to decompile
        - Added support for decompiling Shaders
        - Added ability to log all code entries that failed to decompile to a text file
*/

#region Usings
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Reflection;
using System.Security;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;
using ImageMagick;
// new ui
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Media;
using System.Windows.Shell;
using System.Windows.Input;
// Basic UTMT stuff
using UndertaleModLib.Models;
using UndertaleModLib.Util;
using Underanalyzer.Decompiler;
using Underanalyzer;
using UndertaleModTool;

// just to shorten options code
using OptFlags = UndertaleModLib.Models.UndertaleOptions.OptionsFlags;
using InfoFlags = UndertaleModLib.Models.UndertaleGeneralInfo.InfoFlags;
#endregion

#region Init
// make sure a data.win is loaded
EnsureDataLoaded();

string GameName = Data.GeneralInfo.Name.ToString().Replace(@"""", ""); //Name == "Project" -> Project
int progress = 0;
string projFolder = GetFolder(FilePath) + GameName + ".gmx" + Path.DirectorySeparatorChar;
TextureWorker worker = new TextureWorker();
string gmxDeclaration = "This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!";
string eol = "\n"; // Linux: "\n", Windows: "\r\n";

// for error log
List<string> errLog = new List<string>();

// UnderAnalyzer shit
GlobalDecompileContext decompileContext = new(Data);
Underanalyzer.Decompiler.IDecompileSettings decompilerSettings = Data.ToolInfo.DecompilerSettings;

#region Get Runner Data
// thanks https://stackoverflow.com/questions/17830853/how-can-i-load-a-program-icon-in-c-sharp
#region Extract Icon Functions
internal static class ExtractIcon
{
    [UnmanagedFunctionPointer(CallingConvention.Winapi, SetLastError = true, CharSet = CharSet.Unicode)]
    [SuppressUnmanagedCodeSecurity]
    internal delegate bool ENUMRESNAMEPROC(IntPtr hModule, IntPtr lpszType, IntPtr lpszName, IntPtr lParam);
    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, uint dwFlags);

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern IntPtr FindResource(IntPtr hModule, IntPtr lpName, IntPtr lpType);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr LockResource(IntPtr hResData);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern uint SizeofResource(IntPtr hModule, IntPtr hResInfo);

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    [SuppressUnmanagedCodeSecurity]
    public static extern bool EnumResourceNames(IntPtr hModule, IntPtr lpszType, ENUMRESNAMEPROC lpEnumFunc, IntPtr lParam);


    private const uint LOAD_LIBRARY_AS_DATAFILE = 0x00000002;
    private readonly static IntPtr RT_ICON = (IntPtr)3;
    private readonly static IntPtr RT_GROUP_ICON = (IntPtr)14;

    public static Icon ExtractIconFromExecutable(string path)
    {
        IntPtr hModule = LoadLibraryEx(path, IntPtr.Zero, LOAD_LIBRARY_AS_DATAFILE);
        var tmpData = new List<byte[]>();

        ENUMRESNAMEPROC callback = (h, t, name, l) =>
        {
            var dir = GetDataFromResource(hModule, RT_GROUP_ICON, name);

            // Calculate the size of an entire .icon file.

            int count = BitConverter.ToUInt16(dir, 4);  // GRPICONDIR.idCount
            int len = 6 + 16 * count;                   // sizeof(ICONDIR) + sizeof(ICONDIRENTRY) * count
            for (int i = 0; i < count; ++i)
                len += BitConverter.ToInt32(dir, 6 + 14 * i + 8);   // GRPICONDIRENTRY.dwBytesInRes

            using (var dst = new BinaryWriter(new MemoryStream(len)))
            {
                // Copy GRPICONDIR to ICONDIR.

                dst.Write(dir, 0, 6);

                int picOffset = 6 + 16 * count; // sizeof(ICONDIR) + sizeof(ICONDIRENTRY) * count

                for (int i = 0; i < count; ++i)
                {
                    // Load the picture.

                    ushort id = BitConverter.ToUInt16(dir, 6 + 14 * i + 12);    // GRPICONDIRENTRY.nID
                    var pic = GetDataFromResource(hModule, RT_ICON, (IntPtr)id);

                    // Copy GRPICONDIRENTRY to ICONDIRENTRY.

                    dst.Seek(6 + 16 * i, 0);

                    dst.Write(dir, 6 + 14 * i, 8);  // First 8bytes are identical.
                    dst.Write(pic.Length);          // ICONDIRENTRY.dwBytesInRes
                    dst.Write(picOffset);           // ICONDIRENTRY.dwImageOffset

                    // Copy a picture.

                    dst.Seek(picOffset, 0);
                    dst.Write(pic, 0, pic.Length);

                    picOffset += pic.Length;
                }

                tmpData.Add(((MemoryStream)dst.BaseStream).ToArray());
            }
            return true;
        };
        EnumResourceNames(hModule, RT_GROUP_ICON, callback, IntPtr.Zero);
        byte[][] iconData = tmpData.ToArray();
        using (var ms = new MemoryStream(iconData[0]))
        {
            return new Icon(ms);
        }
    }
    private static byte[] GetDataFromResource(IntPtr hModule, IntPtr type, IntPtr name)
    {
        // Load the binary data from the specified resource.

        IntPtr hResInfo = FindResource(hModule, name, type);

        IntPtr hResData = LoadResource(hModule, hResInfo);

        IntPtr pResData = LockResource(hResData);

        uint size = SizeofResource(hModule, hResInfo);

        byte[] buf = new byte[size];
        Marshal.Copy(pResData, buf, 0, buf.Length);

        return buf;
    }
}

public IMagickImage? Convert_Icon(Bitmap _icon, uint _width, uint _height)
{
    try
    {
        // create new IMagick image
        IMagickImage img = null;

        // Convert bitmap to IMagickImage
        using (var memoryStream = new MemoryStream())
        {
            // save Bitmap to MemoryStream
            _icon.Save(memoryStream, ImageFormat.Png);

            // reset memory stream position
            memoryStream.Seek(0, SeekOrigin.Begin);

            // create a MagickImage from MemoryStream
            img = new MagickImage(memoryStream);
        }

        // stop interpolation
        img.FilterType = FilterType.Point;

        // set size
        var size = new MagickGeometry(_width, _height);
        // maintain the aspect ratio
        size.IgnoreAspectRatio = false;
        // resize image
        img.Resize(size);

        return img;
    }
    catch (Exception)
    {
        // if it fails, just return null
        return null;
    }
}
#endregion

// Get Runner Data
string Runner = GetFolder(FilePath) + GameName + ".exe";
string rName = "", rVersion = "", 
        rCompany = "", rProduct = "", 
        rCopyright = "", rDescription = "";
// Icons
public IMagickImage? WinIcon = null, BigIcon = null;

if (File.Exists(Runner))
{
    var rInfo = System.Diagnostics.FileVersionInfo.GetVersionInfo(Runner);

    rName = Path.GetFileNameWithoutExtension(Runner);
    rVersion = rInfo.FileVersion;
    rCompany = rInfo.CompanyName;
    rProduct = rInfo.ProductName;
    rCopyright = rInfo.LegalCopyright;
    rDescription = rInfo.FileDescription;

    // Icon
    Bitmap ExeIcon = ExtractIcon.ExtractIconFromExecutable(Runner).ToBitmap();
    WinIcon = Convert_Icon(ExeIcon, 48, 48); // 48x48
    BigIcon = Convert_Icon(ExeIcon, 256, 256); // 256x256
}
#endregion

// init this because yeah
CheckDatafiles();

#endregion

#region Main UI

public static class UISettings
{
    public static bool DUMP, // If user chose to go through with decompiling
        // main resources user wants to dump
        OBJT, ROOM, SCPT, TMLN, SOND, SHDR, PATH, FONT, SPRT, BGND;
}

#region Theme Class
public static class Theme
{
    // If Dark Mode
    public static bool IsDark = SettingsWindow.EnableDarkMode;

    // Individual Colors
    public static SolidColorBrush LightGrey = new SolidColorBrush(System.Windows.Media.Color.FromRgb(245, 245, 245));
    public static SolidColorBrush DarkGrey = new SolidColorBrush(System.Windows.Media.Color.FromRgb(45, 45, 48));
    public static SolidColorBrush BG_Grey = new SolidColorBrush(System.Windows.Media.Color.FromRgb(23, 23, 23));
    public static SolidColorBrush BG_White = new SolidColorBrush(System.Windows.Media.Color.FromRgb(230, 230, 230));

    // Simple Colors
    public static SolidColorBrush BasicWhite = System.Windows.Media.Brushes.White;
    public static SolidColorBrush BasicBlack = System.Windows.Media.Brushes.Black;
    public static SolidColorBrush Transparent = System.Windows.Media.Brushes.Transparent;

    // Main Colors
    public static SolidColorBrush WindowBackground = IsDark ? BG_Grey : BG_White;
    public static SolidColorBrush WindowForeground = IsDark ? BasicWhite : BasicBlack;
    public static SolidColorBrush ElementBackground = IsDark ? DarkGrey : LightGrey;
    public static SolidColorBrush ButtonBrush = IsDark ? BG_Grey : LightGrey;
}
#endregion

#region Main Window stuffs
public class UIWindow : Window
{
    public UIWindow()
    {
        Title = "Ultimate_GMS1_Decompiler_v3";
        // remove OS title bar
        WindowStyle = WindowStyle.None;
        AllowsTransparency = false;
        ResizeMode = ResizeMode.NoResize;
        SizeToContent = SizeToContent.WidthAndHeight;
        WindowStartupLocation = WindowStartupLocation.CenterScreen;

        Background = Theme.WindowBackground;
        Foreground = Theme.WindowForeground;//text

        var mainPanel = new StackPanel { Margin = new Thickness(8) };
        var tooltip = new ToolTip();

        #region New Titlebar
        var titleBar = new DockPanel
        {
            Height = 30,
            Background = Theme.ElementBackground,
        };

        var titleText = new TextBlock
        {
            Text = Title,
            VerticalAlignment = VerticalAlignment.Center,
            Margin = new Thickness(10, 0, 0, 0),
            Foreground = Foreground,
        };

        var closeButton = new Button
        {
            Content = "X",
            Width = 40,
            Height = 30,
            Background = Theme.Transparent,
            Foreground = Foreground,
            BorderBrush = Theme.Transparent,
            HorizontalAlignment = HorizontalAlignment.Right,
            Padding = new Thickness(0),
            FontWeight = FontWeights.Bold,
        };

        closeButton.Click += (s, e) => this.Close();

        // Enable window dragging via title bar
        titleBar.MouseLeftButtonDown += (s, e) =>
        {
            if (e.ButtonState == MouseButtonState.Pressed)
                DragMove();
        };

        titleBar.Children.Add(titleText);
        DockPanel.SetDock(closeButton, Dock.Right);
        titleBar.Children.Add(closeButton);
        mainPanel.Children.Insert(0, titleBar);
        #endregion

        // Back to sanity kinda
        mainPanel.Children.Add(new TextBlock
        {
            Text = "Welcome to Ultimate_GMS1_Decompiler_v3!\n\nSelect the parts you want to be included in the project, or just press \"Start Dump\" to do a full Export",
            Margin = new Thickness(0, 20, 0, 8)
        });

        // Resources section
        mainPanel.Children.Add(new TextBlock
        {
            Text = "Select Resources to Dump:",
            FontWeight = FontWeights.Bold,
            Margin = new Thickness(0, 8, 0, 4)
        });

        var resourceGrid = new UniformGrid { Columns = 6 };
        var _OBJT = CreateCheckBox("Objects", true);
        var _ROOM = CreateCheckBox("Rooms", true);
        var _SCPT = CreateCheckBox("Scripts", true);
        var _TMLN = CreateCheckBox("Timelines", true);
        var _SOND = CreateCheckBox("Sounds", true);
        var _SHDR = CreateCheckBox("Shaders", true);
        var _PATH = CreateCheckBox("Paths", true);
        var _FONT = CreateCheckBox("Fonts", true);
        var _SPRT = CreateCheckBox("Sprites", true);
        var _BGND = CreateCheckBox("Tilesets", true);

        resourceGrid.Children.Add(_OBJT);
        resourceGrid.Children.Add(_ROOM);
        resourceGrid.Children.Add(_SCPT);
        resourceGrid.Children.Add(_TMLN);
        resourceGrid.Children.Add(_SOND);
        resourceGrid.Children.Add(_SHDR);
        resourceGrid.Children.Add(_PATH);
        resourceGrid.Children.Add(_FONT);
        resourceGrid.Children.Add(_SPRT);
        resourceGrid.Children.Add(_BGND);

        mainPanel.Children.Add(resourceGrid);

        // OK Button
        var OKBT = new Button
        {
            Content = "Start Dump",
            Height = 48,
            Margin = new Thickness(0, 10, 0, 0),

            Background = Theme.ElementBackground,
            Foreground = Theme.WindowForeground,
            BorderBrush = Theme.ButtonBrush
        };
        OKBT.Click += (o, s) =>
        {
            UISettings.DUMP = true;

            UISettings.OBJT = _OBJT.IsChecked == true;
            UISettings.ROOM = _ROOM.IsChecked == true;
            UISettings.SCPT = _SCPT.IsChecked == true;
            UISettings.TMLN = _TMLN.IsChecked == true;
            UISettings.SOND = _SOND.IsChecked == true;
            UISettings.SHDR = _SHDR.IsChecked == true;
            UISettings.PATH = _PATH.IsChecked == true;
            UISettings.FONT = _FONT.IsChecked == true;
            UISettings.SPRT = _SPRT.IsChecked == true;
            UISettings.BGND = _BGND.IsChecked == true;

            Close();
        };

        mainPanel.Children.Add(OKBT);

        //no scroll bar
        Content = mainPanel;
    }

    private CheckBox CreateCheckBox(string content, bool isChecked = false, bool? enabled = true)
    {
        return new CheckBox
        {
            Content = content,
            IsChecked = isChecked,
            IsEnabled = enabled ?? true,
            Margin = new Thickness(4),
            Background = Theme.ElementBackground,
            Foreground = Theme.WindowForeground
        };
    }
}
#endregion

// open main window
new UIWindow().ShowDialog();

// if exit
if (!UISettings.DUMP)
{
    GC.Collect();
    return;
}

#endregion

#region Helper Functions
string GetFolder(string path)
{
    return Path.GetDirectoryName(path) + Path.DirectorySeparatorChar;
}
string BoolToString(bool value)
{
    // In the GMX file, -1 is true and 0 is false.
    return value ? "-1" : "0";
}

// UnderAnalyzer Decompiling Function
string decompileCode(UndertaleCode codeId)
{
    string code = codeId != null ? new Underanalyzer.Decompiler.DecompileContext(decompileContext, codeId, decompilerSettings).DecompileToString() : "";
    // return code as string to be copied over to .gml file or .gmx asset
    
    return code;
}

// If a code entry is null
string AddtoLog(string assettype, string assetname)
{
    errLog.Add($"{assettype}:   {assetname}");
    return "/*\nDECOMPILER FAILED!\n\n";
}

// got from gms2 decompiler
string GetTexturePageSize()
{
    int[] types = [256, 512, 1024, 2048, 4096, 8192];
    Dictionary<string, int> appearances = new();
    if (Data.EmbeddedTextures.Count == 0)
        return "2048";

    foreach (UndertaleEmbeddedTexture page in Data.EmbeddedTextures)
    {
        for (int i = 0; i < types.Length; i++)
        {
            // Scaled ones have a bunch of textures within it, while non-scaled ones dont and are small as fuck
            // so just ignore the small ones
            if (page.Scaled == 1 && 
                (page.TextureData.Width == types[i] && page.TextureData.Height == types[i])
            )
            {
                string sizeStr = types[i].ToString();
                if (appearances.ContainsKey(sizeStr))
                    appearances[sizeStr]++;
                else
                    appearances[sizeStr] = 1;
            }
        }
    }

    if (appearances.Count == 0)
        return "2048";

    KeyValuePair<string, int> mostAppeared = appearances.Aggregate((l, r) => l.Value > r.Value ? l : r);
    return mostAppeared.Key;
}
#endregion

#region Start Dumping
// check and account for old decomp attempt
if (Directory.Exists(projFolder))
    Directory.Delete(projFolder, true);

Directory.CreateDirectory(projFolder);

// Find Amount of Assets that will be extracted
var resourceNum = 
  (UISettings.OBJT ? Data.GameObjects.Count : 0) +
   (UISettings.SOND ? Data.Sounds.Count : 0) +
    (UISettings.ROOM ? Data.Rooms.Count : 0) +
     (UISettings.SPRT ? Data.Sprites.Count : 0) +
      (UISettings.FONT ? Data.Fonts.Count : 0) +
       (UISettings.SHDR ? Data.Shaders.Count : 0) +
        (UISettings.PATH ? Data.Paths.Count : 0) +
         (UISettings.BGND ? Data.Backgrounds.Count : 0) +
          (UISettings.TMLN ? Data.Timelines.Count : 0) +
           (UISettings.SCPT ? Data.Scripts.Count : 0);

// Export Resources
await Task.WhenAll(
    ExportSprites(),
    ExportBackground(),
    ExportGameObjects(),
    ExportRooms(),
    ExportSounds(),
    ExportScripts(),
    ExportFonts(),
    ExportPaths(),
    ExportTimelines(),
    ExportShaders()
);

// Make Config
ExportConfig();

// Generate project file
GenerateProjectFile();

#endregion
#region Dump Finished
// changed from .Cleanup due to dumb new utmt shit
worker.Dispose();
HideProgressBar();

if (errLog.Count > 0) // If Errors were Encountered during decompilation
{
    File.WriteAllLinesAsync(projFolder + "Error_Log.txt", errLog);
    ScriptMessage($"Done with {errLog.Count} error{(errLog.Count == 1 ? "" : "s")}.\n" + projFolder + "\n\nError_Log.txt can be found in the Decompiled Project with a list of all code entries that failed to decompile");
}
else // If there weren't any errors found
    ScriptMessage("Done with No Errors Encountered!");

// open export folder in file explorer
System.Diagnostics.Process.Start("explorer.exe", projFolder);
#endregion

#region Main Export Functions

#region Sprites
async Task ExportSprites()
{
    if (UISettings.SPRT)
    {
        Directory.CreateDirectory(projFolder + "/sprites/images");
        await Task.Run(() => Parallel.ForEach(Data.Sprites, ExportSprite));
    }
}
void ExportSprite(UndertaleSprite sprite)
{
    UpdateProgressBar(null, $"Exporting Sprite: {sprite.Name.Content}", progress++, resourceNum);

    // Save the sprite GMX
    var gmx = new XDocument(
    new XComment(gmxDeclaration),
    new XElement("sprite",
        new XElement("type", "0"),
        new XElement("xorig", sprite.OriginX.ToString()),
        new XElement("yorigin", sprite.OriginY.ToString()),
        // If SepMasks == precise, set to 0 to avoid shape issues
        new XElement("colkind", sprite.SepMasks == UndertaleSprite.SepMaskType.Precise ? "0" : sprite.BBoxMode.ToString()),
        new XElement("coltolerance", "0"),
        new XElement("sepmasks", sprite.SepMasks.ToString("D")),
        new XElement("bboxmode", sprite.BBoxMode.ToString()),
        new XElement("bbox_left", sprite.MarginLeft.ToString()),
        new XElement("bbox_right", sprite.MarginRight.ToString()),
        new XElement("bbox_top", sprite.MarginTop.ToString()),
        new XElement("bbox_bottom", sprite.MarginBottom.ToString()),
        new XElement("HTile", "0"),
        new XElement("VTile", "0"),
        new XElement("TextureGroups",
            new XElement("TextureGroup0", "0")
        ),
        new XElement("For3D", "0"),
        new XElement("width", sprite.Width.ToString()),
        new XElement("height", sprite.Height.ToString()),
        new XElement("frames")
    )
);

    for (int i = 0; i < sprite.Textures.Count; i++)
    {
        if (sprite.Textures[i]?.Texture != null)
        {
            gmx.Element("sprite").Element("frames").Add(
                new XElement(
                    "frame",
                    new XAttribute("index", i.ToString()),
                    "images\\" + sprite.Name.Content + "_" + i + ".png"
                )
            );
        }
    }

    File.WriteAllText(projFolder + "/sprites/" + sprite.Name.Content + ".sprite.gmx", gmx.ToString() + eol);

    // Save sprite images
    for (int i = 0; i < sprite.Textures.Count; i++)
    {
        if (sprite.Textures[i]?.Texture != null)
        {
            worker.ExportAsPNG(sprite.Textures[i].Texture, projFolder + "/sprites/images/" + sprite.Name.Content + "_" + i + ".png", null, true);
        }
    }
}
#endregion
#region Backgrounds
async Task ExportBackground()
{
    if (UISettings.BGND)
    {
        Directory.CreateDirectory(projFolder + "/background/images");
        await Task.Run(() => Parallel.ForEach(Data.Backgrounds, ExportBackground));
    }
}
void ExportBackground(UndertaleBackground background)
{
    UpdateProgressBar(null, $"Exporting Background: {background.Name.Content}", progress++, resourceNum);

    // Save the backgound GMX
    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("background",
            new XElement("istileset", "-1"),
            new XElement("tilewidth", background.Texture == null ? "0" : background.Texture.BoundingWidth.ToString()),
            new XElement("tileheight", background.Texture == null ? "0" : background.Texture.BoundingHeight.ToString()),
            new XElement("tilexoff", "0"),
            new XElement("tileyoff", "0"),
            new XElement("tilehsep", "0"),
            new XElement("tilevsep", "0"),
            new XElement("HTile", "-1"),
            new XElement("VTile", "-1"),
            new XElement("TextureGroups",
                new XElement("TextureGroup0", "0")
            ),
            new XElement("For3D", "0"),
            new XElement("width", background.Texture == null ? "0" : background.Texture.BoundingWidth.ToString()),
            new XElement("height", background.Texture == null ? "0" : background.Texture.BoundingHeight.ToString()),
            new XElement("data", "images\\" + background.Name.Content + ".png")
        )
    );

    File.WriteAllText(projFolder + "/background/" + background.Name.Content + ".background.gmx", gmx.ToString() + eol);

    // Save background images
    if (background.Texture != null)
        worker.ExportAsPNG(background.Texture, projFolder + "/background/images/" + background.Name.Content + ".png");
}
#endregion
#region Objects
async Task ExportGameObjects()
{
    if (UISettings.OBJT)
    {
        Directory.CreateDirectory(projFolder + "/objects");
        await Task.Run(() => Parallel.ForEach(Data.GameObjects, ExportGameObject));
    }
}
void ExportGameObject(UndertaleGameObject gameObject)
{
    UpdateProgressBar(null, $"Exporting Object: {gameObject.Name.Content}", progress++, resourceNum);

    // Save the object GMX
    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("object",
            new XElement("spriteName", gameObject.Sprite is null ? "<undefined>" : gameObject.Sprite.Name.Content),
            new XElement("solid", BoolToString(gameObject.Solid)),
            new XElement("visible", BoolToString(gameObject.Visible)),
            new XElement("depth", gameObject.Depth.ToString()),
            new XElement("persistent", BoolToString(gameObject.Persistent)),
            new XElement("parentName", gameObject.ParentId is null ? "<undefined>" : gameObject.ParentId.Name.Content),
            new XElement("maskName", gameObject.TextureMaskId is null ? "<undefined>" : gameObject.TextureMaskId.Name.Content),
            new XElement("events"),

            //Physics
            new XElement("PhysicsObject", BoolToString(gameObject.UsesPhysics)),
            new XElement("PhysicsObjectSensor", BoolToString(gameObject.IsSensor)),
            new XElement("PhysicsObjectShape", (uint)gameObject.CollisionShape),
            new XElement("PhysicsObjectDensity", gameObject.Density),
            new XElement("PhysicsObjectRestitution", gameObject.Restitution),
            new XElement("PhysicsObjectGroup", gameObject.Group),
            new XElement("PhysicsObjectLinearDamping", gameObject.LinearDamping),
            new XElement("PhysicsObjectAngularDamping", gameObject.AngularDamping),
            new XElement("PhysicsObjectFriction", gameObject.Friction),
            new XElement("PhysicsObjectAwake", BoolToString(gameObject.Awake)),
            new XElement("PhysicsObjectKinematic", BoolToString(gameObject.Kinematic)),
            new XElement("PhysicsShapePoints")
        )
    );

    // Loop through PhysicsShapePoints List
    for (int _point = 0; _point < gameObject.PhysicsVertices.Count; _point++)
    {
        var _x = gameObject.PhysicsVertices[_point].X;
        var _y = gameObject.PhysicsVertices[_point].Y;

        var physicsPointsNode = gmx.Element("object").Element("PhysicsShapePoints");
        physicsPointsNode.Add(new XElement("points", _x.ToString() + "," + _y.ToString()));
    }

    // Traversing the event type list
    for (int i = 0; i < gameObject.Events.Count; i++)
    {
        // Determine if an event is empty
        if (gameObject.Events[i].Count > 0)
        {
            // Traversing event list
            foreach (var j in gameObject.Events[i])
            {
                var eventsNode = gmx.Element("object").Element("events");

                var eventNode = new XElement("event",
                        new XAttribute("eventtype", i.ToString())
                );

                if (j.EventSubtype == 4)
                {
                    // To get the actual name of the collision object when the event type is a collision event
                    eventNode.Add(new XAttribute("ename", Data.GameObjects[(int)j.EventSubtype].Name.Content));
                }
                else
                {
                    // Get the sub-event number directly
                    eventNode.Add(new XAttribute("enumb", j.EventSubtype.ToString()));
                }

                // Save action
                var actionNode = new XElement("action");

                // Traversing the action list
                foreach (var k in j.Actions)
                {
                    actionNode.Add(
                        new XElement("libid", k.LibID.ToString()),
                        new XElement("id", "603"),// set to 603 so its always code, because that's all we get
                        new XElement("kind", k.Kind.ToString()),
                        new XElement("userelative", BoolToString(k.UseRelative)),
                        new XElement("isquestion", BoolToString(k.IsQuestion)),
                        new XElement("useapplyto", BoolToString(k.UseApplyTo)),
                        new XElement("exetype", k.ExeType.ToString()),
                        new XElement("functionname", k.ActionName.Content),
                        new XElement("codestring", ""),
                        new XElement("whoName", "self"),
                        new XElement("relative", BoolToString(k.Relative)),
                        new XElement("isnot", BoolToString(k.IsNot)),
                        new XElement("arguments",
                            new XElement("argument",
                                new XElement("kind", "1"),
                                new XElement("string", (k.CodeId != null) ? decompileCode(k.CodeId) : AddtoLog("OBJECT", gameObject.Name.Content))
                            )
                        )
                    );
                }
                eventNode.Add(actionNode);
                eventsNode.Add(eventNode);

            }
        }
    }

    File.WriteAllText(projFolder + "/objects/" + gameObject.Name.Content + ".object.gmx", gmx.ToString() + eol);
}
#endregion
#region Rooms
async Task ExportRooms()
{
    if (UISettings.ROOM)
    {
        Directory.CreateDirectory(projFolder + "/rooms");
        await Task.Run(() => Parallel.ForEach(Data.Rooms, ExportRoom));
    }
}
void ExportRoom(UndertaleRoom room)
{
    UpdateProgressBar(null, $"Exporting Room: {room.Name.Content}", progress++, resourceNum);

    // Save the room GMX
    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("room",
            new XElement("caption", room.Caption.Content),
            new XElement("width", room.Width.ToString()),
            new XElement("height", room.Height.ToString()),
            new XElement("vsnap", room.GridHeight.ToString()),//"32"),
            new XElement("hsnap", room.GridWidth.ToString()),//"32"),
            new XElement("isometric", "0"),
            new XElement("speed", room.Speed.ToString()),
            new XElement("persistent", BoolToString(room.Persistent)),
            // remove alpha (background color doesn't have alpha)
            new XElement("colour", (room.BackgroundColor ^ 0xFF000000).ToString()),
            new XElement("showcolour", BoolToString(room.DrawBackgroundColor)),
            new XElement("code", (room.CreationCodeId != null) ? decompileCode(room.CreationCodeId) : ""),
            new XElement("enableViews", BoolToString(room.Flags.HasFlag(UndertaleRoom.RoomEntryFlags.EnableViews))),
            new XElement("clearViewBackground", BoolToString(room.Flags.HasFlag(UndertaleRoom.RoomEntryFlags.ClearViewBackground))),
            new XElement("clearDisplayBuffer", BoolToString(room.Flags.HasFlag(UndertaleRoom.RoomEntryFlags.DoNotClearDisplayBuffer))),//added back cuz yeah
            new XElement("makerSettings",
                new XElement("isSet", 0),
                new XElement("w", 1024),
                new XElement("h", 600),
                new XElement("showGrid", 0),
                new XElement("showObjects", -1),
                new XElement("showTiles", -1),
                new XElement("showBackgrounds", -1),
                new XElement("showForegrounds", -1),
                new XElement("showViews", 0),
                new XElement("deleteUnderlyingObj", 0),
                new XElement("deleteUnderlyingTiles", -1),
                new XElement("page", 1),
                new XElement("xoffset", 0),
                new XElement("yoffset", 0)
            )
        )
    );

    // Room backgrounds
    var backgroundsNode = new XElement("backgrounds");
    foreach (var i in room.Backgrounds)
    {
        var backgroundNode = new XElement("background",
            new XAttribute("visible", BoolToString(i.Enabled)),
            new XAttribute("foreground", BoolToString(i.Foreground)),
            new XAttribute("name", i.BackgroundDefinition is null ? "" : i.BackgroundDefinition.Name.Content),
            new XAttribute("x", i.X.ToString()),
            new XAttribute("y", i.Y.ToString()),
            new XAttribute("htiled", BoolToString(i.TiledHorizontally)),
            new XAttribute("vtiled", BoolToString(i.TiledVertically)),
            new XAttribute("hspeed", i.SpeedX.ToString()),
            new XAttribute("vspeed", i.SpeedY.ToString()),
            new XAttribute("stretch", BoolToString(i.Stretch))//"0")
        );
        backgroundsNode.Add(backgroundNode);
    }
    gmx.Element("room").Add(backgroundsNode);

    // Room views
    var viewsNode = new XElement("views");
    foreach (var i in room.Views)
    {
        var viewNode = new XElement("view",
            new XAttribute("visible", BoolToString(i.Enabled)),
            new XAttribute("objName", i.ObjectId is null ? "<undefined>" : i.ObjectId.Name.Content),
            new XAttribute("xview", i.ViewX.ToString()),
            new XAttribute("yview", i.ViewY.ToString()),
            new XAttribute("wview", i.ViewWidth.ToString()),
            new XAttribute("hview", i.ViewHeight.ToString()),
            new XAttribute("xport", i.PortX.ToString()),
            new XAttribute("yport", i.PortY.ToString()),
            new XAttribute("wport", i.PortWidth.ToString()),
            new XAttribute("hport", i.PortHeight.ToString()),
            new XAttribute("hborder", i.BorderX.ToString()),
            new XAttribute("vborder", i.BorderY.ToString()),
            new XAttribute("hspeed", i.SpeedX.ToString()),
            new XAttribute("vspeed", i.SpeedY.ToString())
        );
        viewsNode.Add(viewNode);
    }
    gmx.Element("room").Add(viewsNode);

    // Room instances
    var instancesNode = new XElement("instances");
    foreach (var i in room.GameObjects)
    {
        var instanceNode = new XElement("instance",
            new XAttribute("objName", i.ObjectDefinition.Name.Content),
            new XAttribute("x", i.X.ToString()),
            new XAttribute("y", i.Y.ToString()),
            new XAttribute("name", "inst_" + i.InstanceID.ToString("X")),
            new XAttribute("locked", "0"),
            new XAttribute("code", (i.CreationCode != null) ? decompileCode(i.CreationCode) : ""),
            new XAttribute("scaleX", i.ScaleX.ToString()),
            new XAttribute("scaleY", i.ScaleY.ToString()),
            new XAttribute("colour", i.Color.ToString()),
            new XAttribute("rotation", i.Rotation.ToString())
        );
        instancesNode.Add(instanceNode);
    }
    gmx.Element("room").Add(instancesNode);

    // Room tiles
    var tilesNode = new XElement("tiles");
    foreach (var i in room.Tiles)
    {
        var tileNode = new XElement("tile",
            new XAttribute("bgName", i.BackgroundDefinition is null ? "" : i.BackgroundDefinition.Name.Content),
            new XAttribute("x", i.X.ToString()),
            new XAttribute("y", i.Y.ToString()),
            new XAttribute("w", i.Width.ToString()),
            new XAttribute("h", i.Height.ToString()),
            new XAttribute("xo", i.SourceX.ToString()),
            new XAttribute("yo", i.SourceY.ToString()),
            new XAttribute("id", i.InstanceID.ToString()),
            new XAttribute("name", "inst_" + i.InstanceID.ToString("X")),
            new XAttribute("depth", i.TileDepth.ToString()),
            new XAttribute("locked", "0"),
            new XAttribute("colour", i.Color.ToString()),
            new XAttribute("scaleX", i.ScaleX.ToString()),
            new XAttribute("scaleY", i.ScaleY.ToString())
        );
        tilesNode.Add(tileNode);
    }
    gmx.Element("room").Add(tilesNode);

    //Room Physics
    gmx.Element("room").Add(
        new XElement("PhysicsWorld", BoolToString(room.World)),
        new XElement("PhysicsWorldTop", room.Top),
        new XElement("PhysicsWorldLeft", room.Left),
        new XElement("PhysicsWorldRight", room.Right),
        new XElement("PhysicsWorldBottom", room.Bottom),
        new XElement("PhysicsWorldGravityX", room.GravityX),
        new XElement("PhysicsWorldGravityY", room.GravityY),
        new XElement("PhysicsWorldPixToMeters", room.MetersPerPixel)
    );

    File.WriteAllText(projFolder + "/rooms/" + room.Name.Content + ".room.gmx", gmx.ToString() + eol);
}
#endregion
#region Sounds
async Task ExportSounds()
{
    if (UISettings.SOND)
    {
        Directory.CreateDirectory(projFolder + "/sound/audio");
        await Task.Run(() => Parallel.ForEach(Data.Sounds, ExportSound));
    }
}
void ExportSound(UndertaleSound sound)
{
    UpdateProgressBar(null, $"Exporting Sound: {sound.Name.Content}", progress++, resourceNum);

    // Save the sound GMX
    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("sound",
            new XElement("kind", Path.GetExtension(sound.File.Content) == ".ogg" ? "3" : "0"),
            new XElement("extension", Path.GetExtension(sound.File.Content)),
            new XElement("origname", "sound\\audio\\" + sound.File.Content),
            new XElement("effects", sound.Effects.ToString()),
            new XElement("volume",
                new XElement("volume", sound.Volume.ToString())
            ),
            new XElement("pan", "0"),
            new XElement("bitRates",
                new XElement("bitRate", "192")
            ),
            new XElement("sampleRates",
                new XElement("sampleRate", "44100")
            ),
            new XElement("types",
                new XElement("type", "1")
            ),
            new XElement("bitDepths",
                new XElement("bitDepth", "16")
            ),
            new XElement("preload", "-1"),
            new XElement("data", Path.GetFileName(sound.File.Content)),
            new XElement("compressed", Path.GetExtension(sound.File.Content) == ".ogg" ? "1" : "0"),
            new XElement("streamed", Path.GetExtension(sound.File.Content) == ".ogg" ? "1" : "0"),
            new XElement("uncompressOnLoad", "0"),
            new XElement("audioGroup", "0")
        )
    );

    File.WriteAllText(projFolder + "/sound/" + sound.Name.Content + ".sound.gmx", gmx.ToString() + eol);

    // Save sound files
    if (sound.AudioFile != null)
        File.WriteAllBytes(projFolder + "/sound/audio/" + sound.File.Content, sound.AudioFile.Data);
    // if sound file is external, add them
    else if (File.Exists($"{Path.GetDirectoryName(FilePath)}\\" + sound.File.Content))
        File.Copy($"{Path.GetDirectoryName(FilePath)}\\" + sound.File.Content, projFolder + "/sound/audio/" + sound.File.Content, true);
}
#endregion
#region Scripts
async Task ExportScripts()
{
    if (UISettings.SCPT)
    {
        Directory.CreateDirectory(projFolder + "/scripts/");
        await Task.Run(() => Parallel.ForEach(Data.Scripts, ExportScript));
    }
}
void ExportScript(UndertaleScript script)
{
    UpdateProgressBar(null, $"Exporting Script: {script.Name.Content}", progress++, resourceNum);

    var scriptpath = projFolder + "/scripts/" + script.Name.Content + ".gml";
    var scriptcode = ((script.Code != null) ? decompileCode(script.Code) : AddtoLog("SCRIPT", script.Name.Content));

    // Save code to GML file
    File.WriteAllText(scriptpath, scriptcode);
}
#endregion
#region Fonts
async Task ExportFonts()
{
    if (UISettings.FONT)
    {
        Directory.CreateDirectory(projFolder + "/fonts/");
        await Task.Run(() => Parallel.ForEach(Data.Fonts, ExportFont));
    }
}
void ExportFont(UndertaleFont font)
{
    UpdateProgressBar(null, $"Exporting Font: {font.Name.Content}", progress++, resourceNum);

    // Save the font GMX
    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("font",
            new XElement("name", font.Name.Content),
            new XElement("size", font.EmSize.ToString()),
            new XElement("bold", BoolToString(font.Bold)),
            new XElement("renderhq", "-1"),
            new XElement("italic", BoolToString(font.Italic)),
            new XElement("charset", font.Charset.ToString()),
            new XElement("aa", font.AntiAliasing.ToString()),
            new XElement("includeTTF", "0"),
            new XElement("TTFName", ""),
            new XElement("texgroups",
                new XElement("texgroup", "0")
            ),
            new XElement("ranges",
                new XElement("range0", font.RangeStart.ToString() + "," + font.RangeEnd.ToString())
            ),
            new XElement("glyphs"),
            new XElement("kerningPairs"),
            new XElement("image", font.Name.Content + ".png")
        )
    );

    var glyphsNode = gmx.Element("font").Element("glyphs");
    foreach (var i in font.Glyphs)
    {
        var glyphNode = new XElement("glyph");
        glyphNode.Add(new XAttribute("character", i.Character.ToString()));
        glyphNode.Add(new XAttribute("x", i.SourceX.ToString()));
        glyphNode.Add(new XAttribute("y", i.SourceY.ToString()));
        glyphNode.Add(new XAttribute("w", i.SourceWidth.ToString()));
        glyphNode.Add(new XAttribute("h", i.SourceHeight.ToString()));
        glyphNode.Add(new XAttribute("shift", i.Shift.ToString()));
        glyphNode.Add(new XAttribute("offset", i.Offset.ToString()));
        glyphsNode.Add(glyphNode);
    }

    File.WriteAllText(projFolder + "/fonts/" + font.Name.Content + ".font.gmx", gmx.ToString() + eol);

    // Save font textures
    worker.ExportAsPNG(font.Texture, projFolder + "/fonts/" + font.Name.Content + ".png");
}
#endregion
#region Paths
async Task ExportPaths()
{
    if (UISettings.PATH)
    {
        Directory.CreateDirectory(projFolder + "/paths");
        await Task.Run(() => Parallel.ForEach(Data.Paths, ExportPath));
    }
}
void ExportPath(UndertalePath path)
{
    UpdateProgressBar(null, $"Exporting Path: {path.Name.Content}", progress++, resourceNum);

    // Save the path GMX
    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("path",
            new XElement("kind", "0"),
            new XElement("closed", BoolToString(path.IsClosed)),
            new XElement("precision", path.Precision.ToString()),
            new XElement("backroom", "-1"),
            new XElement("hsnap", "16"),
            new XElement("vsnap", "16"),
            new XElement("points")
        )
    );
    foreach (var i in path.Points)
    {
        var pointsNode = gmx.Element("path").Element("points");
        pointsNode.Add(
            new XElement("point", $"{i.X.ToString()},{i.Y.ToString()},{i.Speed.ToString()}")
        );
    }

    File.WriteAllText(projFolder + "/paths/" + path.Name.Content + ".path.gmx", gmx.ToString() + eol);
}
#endregion
#region Timelines
async Task ExportTimelines()
{
    if (UISettings.TMLN)
    {
        Directory.CreateDirectory(projFolder + "/timelines");
        await Task.Run(() => Parallel.ForEach(Data.Timelines, ExportTimeline));
    }
}
void ExportTimeline(UndertaleTimeline timeline)
{
    UpdateProgressBar(null, $"Exporting Timeline: {timeline.Name.Content}", progress++, resourceNum);

    // Save the timeline GMX
    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("timeline")
    );
    foreach (var i in timeline.Moments)
    {
        var entryNode = new XElement("entry");
        entryNode.Add(new XElement("step", i.Step));
        entryNode.Add(new XElement("event"));
        foreach (var j in i.Event)
        {
            entryNode.Element("event").Add(
                new XElement("action",
                    new XElement("libid", j.LibID.ToString()),
                    new XElement("id", "603"),// set to always use code
                    new XElement("kind", j.Kind.ToString()),
                    new XElement("userelative", BoolToString(j.UseRelative)),
                    new XElement("isquestion", BoolToString(j.IsQuestion)),
                    new XElement("useapplyto", BoolToString(j.UseApplyTo)),
                    new XElement("exetype", j.ExeType.ToString()),
                    new XElement("functionname", j.ActionName.Content),
                    new XElement("codestring", ""),
                    new XElement("whoName", "self"),
                    new XElement("relative", BoolToString(j.Relative)),
                    new XElement("isnot", BoolToString(j.IsNot)),
                    new XElement("arguments",
                        new XElement("argument",
                            new XElement("kind", "1"),
                            new XElement("string", (j.CodeId != null) ? decompileCode(j.CodeId) : AddtoLog("TIMELINE", timeline.Name.Content))
                        )
                    )
                )
            );
        }
        gmx.Element("timeline").Add(entryNode);
    }

    File.WriteAllText(projFolder + "/timelines/" + timeline.Name.Content + ".timeline.gmx", gmx.ToString() + eol);
}
#endregion
#region Shaders
async Task ExportShaders()
{
    if (UISettings.SHDR)
    {
        Directory.CreateDirectory(projFolder + "/shaders");
        await Task.Run(() => Parallel.ForEach(Data.Shaders, ExportShader));
    }
}

void ExportShader(UndertaleShader shader)
{
    // Vertex and Fragment shit
    string vertex = shader.GLSL_ES_Vertex.Content;
    string fragment = shader.GLSL_ES_Fragment.Content;

    string TrimShader(string shader, string functionName)
    {
        // this fuck ass regex man
        // this finds the position of a basic GM function that is always compiled with the shader
        string pattern = @"\w+\s+" + functionName + @"\s*\([^)]*\)\s*\{" +
                         @"(?>[^{}]+|(?<open>\{)|(?<-open>\}))*" +
                         @"(?(open)(?!))\}";

        // find pattern
        Match match = Regex.Match(shader, pattern, RegexOptions.Singleline);

        // remove basic GM function and all the others above it
        if (match.Success)
            return shader.Substring(match.Index + match.Length).TrimStart();

        return shader;
    }

    // Trim Vertex at vec4 DoLighting
    if (vertex != null) vertex = TrimShader(vertex, "DoLighting");

    // Trim Fragment at void DoFog
    if (fragment != null) fragment = TrimShader(fragment, "DoFog");

    // add gamemaker marker between them since they share the same file
    string finalshader = 
        vertex
        + "//######################_==_YOYO_SHADER_MARKER_==_######################@~" +
        fragment;

    UpdateProgressBar(null, $"Exporting Shader: {shader.Name.Content}", progress++, resourceNum);
    File.WriteAllText(projFolder + "/shaders/" + shader.Name.Content + ".shader", finalshader);
}
#endregion

#region Config Options
void ExportConfig()
{
    #region Setup shit
    // universal func to get both types of flags
    bool HasFlag(dynamic Flag)
    { 
        if (Flag is OptFlags)
            return Data.Options.Info.HasFlag(Flag);
        if (Flag is InfoFlags)
            return Data.GeneralInfo.Info.HasFlag(Flag);

        return false;
    }

    // same thing as above, but returns int values
    int HasFlagAsInt(dynamic Flag)
    {
        return HasFlag(Flag) ? 1 : 0;
    }

    string ConfigDir = $"{projFolder}/Configs/Default/windows";
    Directory.CreateDirectory(ConfigDir);
    #endregion

    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("Config",
            new XElement("Options",
                // Options (Flags)
                new XElement("option_fullscreen", HasFlag(OptFlags.FullScreen)),
                new XElement("option_interpolate", HasFlag(OptFlags.InterpolatePixels)),
                new XElement("option_use_new_audio", HasFlag(OptFlags.UseNewAudio)),
                new XElement("option_noborder", HasFlag(OptFlags.NoBorder)),
                new XElement("option_showcursor", HasFlag(OptFlags.ShowCursor)),
                new XElement("option_sizeable", HasFlag(OptFlags.Sizeable)),
                new XElement("option_stayontop", HasFlag(OptFlags.StayOnTop)),
                new XElement("option_changeresolution", HasFlag(OptFlags.ChangeResolution)),
                new XElement("option_nobuttons", HasFlag(OptFlags.NoButtons)),
                new XElement("option_screenkey", HasFlag(OptFlags.ScreenKey)),
                new XElement("option_helpkey", HasFlag(OptFlags.HelpKey)),
                new XElement("option_quitkey", HasFlag(OptFlags.QuitKey)),
                new XElement("option_savekey", HasFlag(OptFlags.SaveKey)),
                new XElement("option_screenshotkey", HasFlag(OptFlags.ScreenShotKey)),
                new XElement("option_closeesc", HasFlag(OptFlags.CloseSec)),
                new XElement("option_freeze", HasFlag(OptFlags.Freeze)),
                new XElement("option_showprogress", HasFlagAsInt(OptFlags.ShowProgress)),
                new XElement("option_loadtransparent", HasFlag(OptFlags.LoadTransparent)),
                new XElement("option_scaleprogress", HasFlag(OptFlags.ScaleProgress)),
                new XElement("option_displayerrors", HasFlag(OptFlags.DisplayErrors)),
                new XElement("option_writeerrors", HasFlag(OptFlags.WriteErrors)),
                new XElement("option_aborterrors", HasFlag(OptFlags.AbortErrors)),
                new XElement("option_variableerrors", HasFlag(OptFlags.VariableErrors)),
                new XElement("option_psvita_fronttouch", BoolToString(HasFlag(OptFlags.UseFrontTouch))),//PS Vita shit
                new XElement("option_psvita_reartouch", BoolToString(HasFlag(OptFlags.UseRearTouch))),//uses -1 and 0 for some fucking reason
                new XElement("option_use_fast_collision", HasFlag(OptFlags.UseFastCollision)),
                new XElement("option_fast_collision_compatibility", HasFlag(OptFlags.FastCollisionCompatibility)),
                // Options (REAL SHIT)
                new XElement("option_scale", Data.Options.Scale),
                new XElement("option_windowcolor", $"${Data.Options.WindowColor:X8}"), // uint as "$AABBGGRR"
                new XElement("option_colordepth", Data.Options.ColorDepth),
                new XElement("option_resolution", Data.Options.Resolution),
                new XElement("option_frequency", Data.Options.Frequency),
                new XElement("option_sync_vertex", Data.Options.VertexSync),
                new XElement("option_loadalpha", Data.Options.LoadAlpha),

                // Info
                new XElement("option_display_name", Data.GeneralInfo.DisplayName.Content),
                new XElement("option_gameid", Data.GeneralInfo.GameID),
                new XElement("option_borderless", HasFlag(InfoFlags.BorderlessWindow)),
                new XElement("option_windows_save_location", HasFlagAsInt(InfoFlags.UseAppDataSaveLocation)),
                new XElement("option_windows_texture_page", GetTexturePageSize())
            )
        )
    );

    // for appending shit
    var OptionsNode = gmx.Element("Config").Element("Options");

    // Runner Data and shit
    if (File.Exists(Runner))
    {
        OptionsNode.Add(
            new XElement("option_windows_company_info", rCompany),
            new XElement("option_windows_copyright_info", rCopyright),
            new XElement("option_windows_description_info", rDescription),
            new XElement("option_windows_product_info", rProduct),
            new XElement("option_windows_game_icon", "runner_icon.ico")
        );
        if (WinIcon != null) WinIcon.Write($"{ConfigDir}/runner_icon.ico");
        if (BigIcon != null) BigIcon.Write($"{ConfigDir}/Runner_Icon_256.ico");
    }

    // splash screen handling
    if (File.Exists($"{projFolder}/splash.png"))
    {
        OptionsNode.Add(
            new XElement("option_windows_splash_screen", "Configs\\Default\\windows\\splash.png"),
            new XElement("option_windows_use_splash", 1)
        );
        File.Copy($"{projFolder}/splash.png", $"{ConfigDir}/splash.png");
    }
    else
        OptionsNode.Add(new XElement("option_windows_use_splash", 0));

    // add steam id if enabled
    var SteamEnabled = HasFlag(InfoFlags.SteamEnabled);
    if (SteamEnabled)
    {
        OptionsNode.Add(
            new XElement("option_windows_enable_steam", SteamEnabled),
            new XElement("option_windows_steam_app_id", Data.GeneralInfo.SteamAppID)
        );
    }

    // constants in the data file.
    foreach (UndertaleOptions.Constant con in Data.Options.Constants)
    {
        string conStr = con.Name.Content;
        var conVal = con.Value.Content;

        if (conStr.Contains("SleepMargin"))
            OptionsNode.Add(new XElement("option_windows_sleep_margin", Int32.Parse(conVal)));

        // TODO - This exists, but idk the XML element name
        //if (conStr.Contains("DrawColour"))
        //    OptionsNode.Add(new XElement("option_draw_colour", UInt32.Parse(conVal)));
    }

    // i gotta man
    OptionsNode.Add(new XElement("option_information",
        $@"This is a Decompilation of {Data.GeneralInfo.DisplayName.Content}

--------------------------------------------------------
Project Decompiled by Ultimate_GMS1_Decompiler_v3.csx
	Improved by burnedpopcorn180
		Original Version by cubeww and CST1229"));

    File.WriteAllText(projFolder + "/Configs/Default.config.gmx", gmx.ToString() + eol);
}
#endregion
#region DataFiles

int TotalFiles = 0;
void CheckDatafiles()
{
    // check all files in all subdirectories
    foreach (var file in Directory.GetFiles(GetFolder(FilePath), "*", SearchOption.AllDirectories))
    {
        // Skip these files                                                        //also get rid of sounds because yeah
        if (new[] { ".dll", ".exe", ".ini", ".win", ".unx", ".droid", ".ios", ".dat", ".mp3", ".ogg", ".wav" }.Contains(Path.GetExtension(file).ToLower()))
            continue;

        // Skip export folder
        if (Path.GetDirectoryName(file).Contains($"{GameName}.gmx")) continue;

        // add to the shit
        TotalFiles++;
    }
}

void AddDatafiles(XElement element, string filepath)
{
    #region Setup
    // get relative directory name for xml
    string outputPath = Path.Combine($"{projFolder}/datafiles", Path.GetRelativePath(GetFolder(FilePath), filepath));
    var dirName = new DirectoryInfo(outputPath).Name;

    // Skip export folder
    if (dirName == $"{GameName}.gmx") return;

    // start adding folder to xml
    element.Add(
        new XElement("datafiles", 
            new XAttribute("number", TotalFiles), // number of ALL files
            new XAttribute("name", dirName)// name of folder
        )
    );
    // save element pointer for files
    var DatafileXML = element.Element("datafiles");
    #endregion

    // Copy and Record all Files
    foreach (var file in Directory.GetFiles(filepath))
    {
        #region Copy Files

        // Skip these files                                                        //also get rid of sounds because yeah
        if (new[] { ".dll", ".exe", ".ini", ".win", ".unx", ".droid", ".ios", ".dat", ".mp3", ".ogg", ".wav" }.Contains(Path.GetExtension(file).ToLower()))
            continue;

        string relativePath = Path.GetRelativePath(GetFolder(FilePath), file);
        string destinationFile = Path.Combine(projFolder + "/datafiles", relativePath);

        // Skip export folder
        if (Path.GetDirectoryName(file).Contains($"{GameName}.gmx")) continue;

        // Ensure it exists
        Directory.CreateDirectory(Path.GetDirectoryName(destinationFile));

        // Copy the file
        File.Copy(file, destinationFile, true);

        #endregion
        #region Add Files to XML

        string FileName = Path.GetFileName(file);
        long FileSize = new FileInfo(file).Length;

        DatafileXML.Add(
            new XElement("datafile",
                new XElement("name", FileName),
                new XElement("exists", -1),
                new XElement("size", FileSize),
                new XElement("exportAction", 2),
                new XElement("exportDir", ""), //empty cuz yeah
                new XElement("overwrite", 0),
                new XElement("freeData", -1),
                new XElement("removeEnd", 0),
                new XElement("store", 0),
                // im skipping config options, fuck off
                new XElement("filename", FileName) // basically just copy of name
            )
        );

        #endregion
    }

    // Search Sub-Directories
    foreach (var dir in Directory.GetDirectories(filepath))
    {
        // Skip export folder
        if (Path.GetDirectoryName(dir).Contains($"{GameName}.gmx")) continue;

        // recursive function no way
        AddDatafiles(DatafileXML, dir);
    }
}
#endregion

#endregion

#region Generate GMX
void GenerateProjectFile()
{
    UpdateProgressBar(null, $"Generating Project File...", progress++, resourceNum);

    var gmx = new XDocument(
        new XComment(gmxDeclaration),
        new XElement("assets", 
            // add config shit
            new XElement("Configs", new XAttribute("name", "configs"),
                new XElement("Config", "Configs\\Default")
            )
        )
    );

    XElement GMXAssets = gmx.Element("assets");

    // what do you think
    AddDatafiles(GMXAssets, GetFolder(FilePath));

    // Write all resource indexes to project.gmx
    if (UISettings.SOND) WriteIndexes<UndertaleSound>(GMXAssets, "sounds", "sound", Data.Sounds, "sound", "sound\\");
    if (UISettings.SPRT) WriteIndexes<UndertaleSprite>(GMXAssets, "sprites", "sprites", Data.Sprites, "sprite", "sprites\\");
    if (UISettings.BGND) WriteIndexes<UndertaleBackground>(GMXAssets, "backgrounds", "background", Data.Backgrounds, "background", "background\\");
    if (UISettings.SCPT) WriteIndexes<UndertaleScript>(GMXAssets, "scripts", "scripts", Data.Scripts, "script", "scripts\\", ".gml");
    if (UISettings.FONT) WriteIndexes<UndertaleFont>(GMXAssets, "fonts", "fonts", Data.Fonts, "font", "fonts\\");
    if (UISettings.OBJT) WriteIndexes<UndertaleGameObject>(GMXAssets, "objects", "objects", Data.GameObjects, "object", "objects\\");
    if (UISettings.ROOM) WriteIndexes<UndertaleRoom>(GMXAssets, "rooms", "rooms", Data.Rooms, "room", "rooms\\");
    if (UISettings.PATH) WriteIndexes<UndertalePath>(GMXAssets, "paths", "paths", Data.Paths, "path", "paths\\");
    if (UISettings.TMLN) WriteIndexes<UndertaleTimeline>(GMXAssets, "timelines", "timelines", Data.Timelines, "timeline", "timelines\\");
    if (UISettings.SHDR) WriteIndexes<UndertaleShader>(GMXAssets, "shaders", "shaders", Data.Shaders, "shader", "shaders\\", ".shader");

    File.WriteAllText(projFolder + GameName + ".project.gmx", gmx.ToString() + eol);
}

void WriteIndexes<T>(XElement rootNode, string elementName, string attributeName, IList<T> dataList, string oneName, string resourcePath, string fileExtension = "")
{
    var resourcesNode = new XElement(elementName,
        new XAttribute("name", attributeName)
    );
    foreach (UndertaleNamedResource i in dataList)
    {
        var resourceNode = new XElement(oneName, resourcePath + i.Name.Content + fileExtension);
        resourcesNode.Add(resourceNode);
    }
    rootNode.Add(resourcesNode);
}
#endregion